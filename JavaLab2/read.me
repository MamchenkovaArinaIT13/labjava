 ОТЧЕТ ПО ЛАБОРАТОРНОЙ РАБОТЕ №2 ПО JAVA

ОБЩЕЕ ОПИСАНИЕ РАБОТЫ

Программа представляет собой консольное приложение с меню для выполнения 6 задач по объектно-ориентированному программированию. Приложение поддерживает два режима ввода данных: ручной ввод пользователем и автоматический ввод с готовыми данными. Реализована система валидации ввода для обработки некорректных данных.

СТРУКТУРА ПРОГРАММЫ

Класс Main

Назначение: Точка входа в программу
Используемые компоненты:

· MenuSystem - для управления основным потоком программы

Принцип работы:

«java
public static void main(String[] args) {
    MenuSystem menu = new MenuSystem();  // Создание экземпляра системы меню
    menu.showMainMenu();                 // Запуск основного цикла меню
    menu.close();                        // Освобождение ресурсов при завершении
}»

Что происходит:

1. Создается объект MenuSystem
2. Вызывается метод showMainMenu() для запуска пользовательского интерфейса
3. После завершения работы вызывается close() для очистки ресурсов


КЛАСС MenuSystem

Конструктор MenuSystem()

Использует: Scanner scanner = new Scanner(System.in)
Принцип работы: Создает новый объект Scanner для чтения ввода из системного потока ввода

Метод showMainMenu()

Использует:

· Scanner.nextLine() - для чтения строки ввода
· autoInputMenu() - при выборе опции 1
· manualInputMenu() - при выборе опции 2

Принцип работы:

«java
public void showMainMenu() {
    while (true) {  // Бесконечный цикл для постоянного отображения меню
        System.out.println("\n=== ГЛАВНОЕ МЕНЮ ===");
        // Вывод вариантов меню
        String choice = scanner.nextLine().trim();  // Чтение и очистка ввода
        
        switch (choice) {
            case "1": autoInputMenu(); break;    // Переход к авто-вводу
            case "2": manualInputMenu(); break;  // Переход к ручному вводу
            case "3": return;                    // Выход из программы
            default: System.out.println("Неверный выбор!");  // Обработка ошибки
        }
    }
}»

Метод autoInputMenu()

Использует: методы executeAutoTask1()-executeAutoTask6()
Принцип работы:

· Отображает подменю с 6 задачами
· В цикле обрабатывает выбор пользователя
· Для каждой задачи вызывает соответствующий метод выполнения

Метод executeAutoTask1() - Демонстрация класса Name

Использует: конструкторы класса Name с разными параметрами
Принцип работы:

«java
private void executeAutoTask1() {
    // Создание объектов разными конструкторами
    Name person1 = new Name("Клеопатра");  // Только имя
    Name person2 = new Name("Пушкин", "Александр", "Сергеевич"); // Полное ФИО
    Name person3 = new Name("Маяковский", "Владимир"); // Фамилия и имя
    
    // Вызов toString() для демонстрации форматирования
    System.out.println("Только имя: " + person1);
    System.out.println("Полное ФИО: " + person2);
    System.out.println("Фамилия и имя: " + person3);
}»

Метод executeAutoTask2() - Демонстрация класса House

Использует: конструктор House(int floors) и метод toString()
Принцип работы:

«java
private void executeAutoTask2() {
    // Создание домов с разным количеством этажей
    House house1 = new House(1);    // 1 этаж
    House house2 = new House(5);    // 5 этажей  
    House house3 = new House(23);   // 23 этажа
    House invalidHouse = new House(0); // Некорректное значение
    
    // Демонстрация склонения слова "этаж"
    System.out.println("1 этаж: " + house1);
    System.out.println("5 этажей: " + house2);
    System.out.println("23 этажа: " + house3);
    System.out.println("0 этажей: " + invalidHouse);
}»

Метод executeAutoTask3() - Связь Department и Employee

Использует:

· Departament - создание отдела
· Employee - создание сотрудников
· setManager() - назначение руководителя

Принцип работы:

«java
private void executeAutoTask3() {
    Departament departament = new Departament("IT");  // Создание отдела
    
    // Создание сотрудников (автоматически добавляются в отдел)
    Employee employee1 = new Employee("Козлов", departament);
    Employee employee2 = new Employee("Петров", departament);
    Employee employee3 = new Employee("Сидоров", departament);
    
    departament.setManager(employee1);  // Назначение руководителя
    
    // Вывод информации о сотрудниках
    System.out.println(employee1);
    System.out.println(employee2);
    System.out.println(employee3);
}»

Метод executeAutoTask4() - Получение списка сотрудников

Использует: getAllDepartmentEmployees() из класса Employee
Принцип работы:

«java
private void executeAutoTask4() {
    Departament departament = new Departament("IT");
    Employee employee1 = new Employee("Козлов", departament);
    Employee employee2 = new Employee("Петров", departament);
    
    // Получение списка через разных сотрудников
    List<Employee> employeesFromKozlov = employee1.getAllDepartmentEmployees();
    List<Employee> employeesFromPetrov = employee2.getAllDepartmentEmployees();
    
    // Демонстрация, что оба списка идентичны
    for (Employee emp : employeesFromKozlov) {
        System.out.println("- " + emp.getName());
    }
}»

Метод executeAutoTask5() - Альтернативный формат Name

Использует: toStringNow() метод класса Name
Принцип работы: Сравнивает обычный и альтернативный форматы вывода для разных комбинаций имен

Метод executeAutoTask6() - Арифметика дробей

Использует: все арифметические методы класса Fraction
Принцип работы:

«java
private void executeAutoTask6() {
    Fraction f1 = new Fraction(1, 3);
    Fraction f2 = new Fraction(2, 3);
    
    // Демонстрация всех операций
    System.out.println(f1 + " + " + f2 + " = " + f1.add(f2));
    System.out.println(f1 + " - " + f2 + " = " + f1.subtract(f2));
    System.out.println(f1 + " * " + f2 + " = " + f1.multiply(f2));
    System.out.println(f1 + " / " + f2 + " = " + f1.divide(f2));
}»

Методы валидации ввода

getValidNameInput(String fieldName):
Использует: регулярные выражения для проверки
Принцип работы:

«java
private String getValidNameInput(String fieldName) {
    while (true) {
        String input = scanner.nextLine().trim();
        
        if (input.isEmpty()) {
            System.out.print("Ошибка! " + fieldName + " не может быть пустым: ");
            continue;
        }
        
        if (containsNumbers(input)) {  // Проверка через regex ".*\\d.*"
            System.out.print("Ошибка! " + fieldName + " не может содержать цифры: ");
            continue;
        }
        
        if (!isValidName(input)) {  // Проверка через regex "^[a-zA-Zа-яА-ЯёЁ\\-\\s]+$"
            System.out.print("Ошибка! Недопустимые символы: ");
            continue;
        }
        
        return input;  // Возврат только при корректном вводе
    }
}»

getIntInput():
Использует: Integer.parseInt() и обработку исключений
Принцип работы:

«java
private int getIntInput() {
    while (true) {
        try {
            String input = scanner.nextLine().trim();
            return Integer.parseInt(input);  // Попытка преобразования
        } catch (NumberFormatException e) {
            System.out.print("Ошибка! Введите целое число: ");  // Повтор при ошибке
        }
    }
}»


КЛАСС Name

Конструкторы

Name(String firstname):
Использует: прямое присвоение значения полю
Принцип работы:

«java
public Name(String firstname) {
    this.firstname = firstname;  // Установка только имени
    // lastname и surrname остаются null
}»

Name(String lastname, String firstname):
Принцип работы:

«java
public Name(String lastname, String firstname) {
    this.lastname = lastname;    // Установка фамилии
    this.firstname = firstname;  // Установка имени
    // surrname остается null
}»

Name(String lastname, String firstname, String surrname):
Принцип работы: Устанавливает все три поля класса

Метод toString()

Использует: конкатенацию строк и проверки на null
Принцип работы:

«java
public String toString() {
    String res = "";
    // Последовательное добавление: Фамилия → Имя → Отчество
    if (this.lastname != null && !this.lastname.isEmpty()) {
        res += this.lastname;  // Начало с фамилии
    }
    if (this.firstname != null && !this.firstname.isEmpty()) {
        if (res.isEmpty()) {
            res = this.firstname;  // Если фамилии нет, начать с имени
        } else {
            res += " " + this.firstname;  // Добавить имя через пробел
        }
    }
    if (this.surrname != null && !this.surrname.isEmpty()) {
        if (res.isEmpty()) {
            res = this.surrname;  // Если ничего нет, начать с отчества
        } else {
            res += " " + this.surrname;  // Добавить отчество через пробел
        }
    }
    return res;
}»

Метод toStringNow()

Принцип работы: Аналогичен toString(), но порядок: Имя → Отчество → Фамилия

ТЕСТИРОВАНИЕ КЛАССА Name:

Автоматический ввод:

«java
// Тест 1: Только имя
Name person1 = new Name("Клеопатра");
System.out.println(person1);  // Ожидаемый результат: "Клеопатра"

// Тест 2: Полное ФИО  
Name person2 = new Name("Пушкин", "Александр", "Сергеевич");
System.out.println(person2);  // Ожидаемый результат: "Пушкин Александр Сергеевич"

// Тест 3: Фамилия и имя
Name person3 = new Name("Маяковский", "Владимир");
System.out.println(person3);  // Ожидаемый результат: "Маяковский Владимир"»

Ручной ввод:

· Вход: имя "Мария" → Результат: "Мария"
· Вход: фамилия "Иванов", имя "Иван", отчество "Иванович" → Результат: "Иванов Иван Иванович"
· Вход: только отчество "Петрович" → Результат: "Петрович"


КЛАСС House

Конструктор House(int floor)

Использует: проверку условия и вывод сообщения об ошибке
Принцип работы:

«java
public House(int floor) {
    if(floor <= 0) {
        // Вывод сообщения в консоль при некорректных данных
        System.out.println("У дома не может быть <=0 этажей");
    } else {
        this.floor = floor;  // Установка значения при корректных данных
    }
}»

Метод toString()

Использует: оператор % для определения последней цифры числа
Принцип работы:

«java
public String toString() {
    if(this.floor <= 0) {
        return "Дом должен содержать >0 этажей";  // Обработка ошибки
    }
    
    // Логика определения склонения по правилам русского языка:
    if(this.floor % 10 == 1 && this.floor % 100 != 11) {
        // Для чисел, оканчивающихся на 1 (кроме 11): 1, 21, 31 этаж
        return "Дом с " + this.floor + " этажом";
    } else if((this.floor % 10 >= 2 && this.floor % 10 <= 4) && 
              (!(this.floor % 100 >= 12 && this.floor % 100 <= 14))) {
        // Для чисел 2-4 (кроме 12-14): 2, 3, 4, 22, 23, 24 этажа
        return "Дом с " + this.floor + " этажами";
    } else {
        // Для всех остальных случаев: 5-20, 25-30 этажей
        return "Дом с " + this.floor + " этажами";
    }
}»

ТЕСТИРОВАНИЕ КЛАССА House:

Автоматический ввод:

«java
// Тест 1: 1 этаж (особое склонение)
House house1 = new House(1);
System.out.println(house1);  // Ожидаемый результат: "Дом с 1 этажом"

// Тест 2: 5 этажей (множественное число)
House house2 = new House(5);
System.out.println(house2);  // Ожидаемый результат: "Дом с 5 этажами"

// Тест 3: 23 этажа (особый случай)
House house3 = new House(23);
System.out.println(house3);  // Ожидаемый результат: "Дом с 23 этажами"

// Тест 4: Некорректное значение
House invalidHouse = new House(0);
System.out.println(invalidHouse);  // Ожидаемый результат: "Дом должен содержать >0 этажей"»

Ручной ввод:

· Вход: 3 этажа → Результат: "Дом с 3 этажами"
· Вход: 21 этаж → Результат: "Дом с 21 этажом"
· Вход: 12 этажей → Результат: "Дом с 12 этажами"



КЛАСС Fraction

Конструктор Fraction(int numerator, int denominator)

Использует: проверку знаменателя и вызов simplify()
Принцип работы:

«java
public Fraction(int numerator, int denominator) {
    if (denominator == 0) {
        throw new IllegalArgumentException("Знаменатель не может быть равен нулю");
    }
    this.numerator = numerator;
    this.denominator = denominator;
    simplify();  // Автоматическое сокращение дроби при создании
}»

Метод gcd() (Наибольший общий делитель)

Использует: рекурсивный алгоритм Евклида
Принцип работы:

«java
private int gcd(int a, int b) {
    // Рекурсивный алгоритм Евклида:
    return b == 0 ? Math.abs(a) : gcd(b, a % b);
    // Если b == 0, возвращаем |a|
    // Иначе рекурсивно вызываем gcd(b, a % b)
}»

Метод simplify() - сокращение дроби

Использует: метод gcd() и проверку знака знаменателя
Принцип работы:

«java
private void simplify() {
    int gcd = gcd(numerator, denominator);  // Находим НОД
    numerator /= gcd;    // Делим числитель на НОД
    denominator /= gcd;  // Делим знаменатель на НОД

    // Обеспечиваем положительный знаменатель
    if (denominator < 0) {
        numerator = -numerator;    // Меняем знак числителя
        denominator = -denominator; // Меняем знак знаменателя
    }
}»

Арифметические операции

Метод add():
Использует: математическую формулу сложения дробей
Принцип работы:

«java
public Fraction add(Fraction other) {
    // Формула: a/b + c/d = (a*d + c*b)/(b*d)
    int newNumerator = this.numerator * other.denominator + 
                      other.numerator * this.denominator;
    int newDenominator = this.denominator * other.denominator;
    return new Fraction(newNumerator, newDenominator);  // Автоматическое сокращение
}»

Метод subtract():
Принцип работы: Аналогично add(), но с вычитанием

Метод multiply():
Использует: формулу умножения дробей
Принцип работы:

«java
public Fraction multiply(Fraction other) {
    // Формула: a/b * c/d = (a*c)/(b*d)
    int newNumerator = this.numerator * other.numerator;
    int newDenominator = this.denominator * other.denominator;
    return new Fraction(newNumerator, newDenominator);
}»

Метод divide():
Использует: проверку деления на ноль и формулу деления
Принцип работы:

«java
public Fraction divide(Fraction other) {
    if (other.numerator == 0) {
        throw new ArithmeticException("Деление на ноль");  // Проверка ошибки
    }
    // Формула: a/b ÷ c/d = a/b * d/c = (a*d)/(b*c)
    int newNumerator = this.numerator * other.denominator;
    int newDenominator = this.denominator * other.numerator;
    return new Fraction(newNumerator, newDenominator);
}»

ТЕСТИРОВАНИЕ КЛАССА Fraction:

Автоматический ввод:

// Тест 1: Сложение
Fraction f1 = new Fraction(1, 3);
Fraction f2 = new Fraction(2, 3);
System.out.println(f1 + " + " + f2 + " = " + f1.add(f2));  
// Ожидаемый результат: "1/3 + 2/3 = 1"

// Тест 2: Вычитание
Fraction f3 = new Fraction(3, 4);
Fraction f4 = new Fraction(5, 6);
System.out.println(f3 + " - " + f4 + " = " + f3.subtract(f4));
// Ожидаемый результат: "3/4 - 5/6 = -1/12"

// Тест 3: Умножение
System.out.println(f1 + " * " + f2 + " = " + f1.multiply(f2));
// Ожидаемый результат: "1/3 * 2/3 = 2/9"

// Тест 4: Деление
System.out.println(f3 + " / " + f4 + " = " + f3.divide(f4));
// Ожидаемый результат: "3/4 / 5/6 = 9/10"


Ручной ввод:

· Вход: 2/3 и 1/4 →
  · Сложение: 11/12
  · Вычитание: 5/12
  · Умножение: 1/6
  · Деление: 8/3


КЛАССЫ Employee и Departament

Конструктор Employee(String name, Departament departament)

Использует: автоматическую регистрацию в отделе
Принцип работы:

«java
public Employee(String name, Departament departament) {
    this.name = name;
    this.departament = departament;
    if (departament != null) {
        departament.addEmployee(this);  // Автоматическое добавление в отдел
    }
}»

Метод addEmployee() в Departament

Использует: проверку на дубликаты через contains()
Принцип работы:

«java
public void addEmployee(Employee employee) {
    if (!employees.contains(employee)) {
        employees.add(employee);  // Добавление только если сотрудника нет в списке
    }
}»

Метод getAllDepartmentEmployees() в Employee

Использует: делегирование вызова отделу
Принцип работы:

«java
public List<Employee> getAllDepartmentEmployees() {
    return departament.getEmployees();  // Получение списка через отдел
}»

Метод toString() в Employee

Использует: тернарные операторы для обработки null значений
Принцип работы:

«java
public String toString() {
    // Обработка возможных null значений
    String managerName = (departament != null && departament.getManager() != null)
            ? departament.getManager().getName() : "не назначен";
    String departmentName = (departament != null) ? departament.getName1() : "не указан";

    return this.name + " работает в отделе " + departmentName
            + ", начальник которого " + managerName;
}»

ТЕСТИРОВАНИЕ КЛАССОВ Employee и Departament:

Автоматический ввод:

// Создание отдела и сотрудников
Departament departament = new Departament("IT");
Employee emp1 = new Employee("Козлов", departament);
Employee emp2 = new Employee("Петров", departament);
departament.setManager(emp1);

// Тест информации о сотрудниках
System.out.println(emp1);  // "Козлов работает в отделе IT, начальник которого Козлов"
System.out.println(emp2);  // "Петров работает в отделе IT, начальник которого Козлов"

// Тест получения списка сотрудников
List<Employee> employees = emp1.getAllDepartmentEmployees();
// Ожидаемый результат: список [Козлов, Петров]


Ручной ввод:

· Отдел: "Финансы"
· Сотрудники: "Смирнов", "Петрова", "Васильев"
· Начальник: "Смирнов"
· Результат: корректное отображение информации о сотрудниках и их начальнике

ЗАКЛЮЧЕНИЕ

Все 6 задач успешно реализованы и протестированы. Программа демонстрирует принципы ООП: инкапсуляцию, перегрузку методов и конструкторов. Реализована удобная система меню с защитой от некорректного ввода. Каждый класс решает конкретную задачу и корректно обрабатывает различные сценарии использования. Все методы протестированы в обоих режимах ввода.

